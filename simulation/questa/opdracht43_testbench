library ieee;
use ieee.std_logic_1164.all;
use ieee.math_real.all;

entity opdracht43_testbench is
end entity opdracht43_testbench;

architecture testbench of opdracht43_testbench is
	component opdracht43 is

		generic (N 	: integer := 8);

		port(	clk 		: in 	std_logic;
		  	rst_n 		: in 	std_logic;
		  	button 		: in 	std_logic;
		  	pressed		: out std_logic;
		  	pressed_event 	: out std_logic;
		  	released_event 	: out std_logic);

	end component;
	
	constant N : integer := 8; 
	constant CLOCK_PERIOD : time := 20 ns;

	signal clk 	: std_logic := '1';
	signal rst_n 	: std_logic := '1';
	signal button	: std_logic := '1';
	
	signal pressed 		: std_logic := '1';
	signal pressed_event 	: std_logic := '1';
	signal released_event 	: std_logic := '1';

begin

	DUT : opdracht43

		generic map(N => N)
		port map(clk => clk,
	 		 rst_n => rst_n,
			 button => button,
			 pressed => pressed,
			 pressed_event => pressed_event,
			 released_event => released_event
			 );

	clk <= not clk after 0.5 * CLOCK_PERIOD;

	stimuli: process

		variable seed1, seed2 : positive := 1;
    		variable rand_real : real;

	begin
		rst_n <= '0';

		wait for 0.25 * CLOCK_PERIOD;

		rst_n <= '1';

		-- Here debounce is being simulated by genarating random bursts.
		for i in 0 to 5000 loop
        		uniform(seed1, seed2, rand_real);
			button <= not button;

			for j in 0 to integer(rand_real * 10.0) loop
        			wait until rising_edge(clk);
			end loop;
    		end loop;
		
		-- Here te debounce is gone and the button is being pressed.
		button <= '0';
		
		wait for 500000 * CLOCK_PERIOD;

		-- Here debounce is being simulated by genarating random bursts.
		for i in 0 to 5000 loop
        		uniform(seed1, seed2, rand_real);
			button <= not button;

			for j in 0 to integer(rand_real * 10.0) loop
        			wait until rising_edge(clk);
			end loop;
    		end loop;

		wait;
	end process stimuli;
end architecture testbench;